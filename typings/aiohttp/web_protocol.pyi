"""
This type stub file was generated by pyright.
"""

import asyncio
import yarl
from logging import Logger
from typing import Any, Awaitable, Callable, Optional, TYPE_CHECKING, Type
from .abc import AbstractAccessLogger, AbstractStreamWriter
from .base_protocol import BaseProtocol
from .http import HttpVersion10, RawRequestMessage
from .streams import StreamReader
from .web_request import BaseRequest
from .web_response import StreamResponse
from .web_server import Server

__all__ = ('RequestHandler', 'RequestPayloadError', 'PayloadAccessError')
if TYPE_CHECKING:
    ...
_RequestFactory = Callable[[RawRequestMessage, StreamReader, 'RequestHandler', AbstractStreamWriter, 'asyncio.Task[None]'], BaseRequest]
_RequestHandler = Callable[[BaseRequest], Awaitable[StreamResponse]]
ERROR = RawRequestMessage('UNKNOWN', '/', HttpVersion10, {  }, {  }, True, False, False, False, yarl.URL('/'))
class RequestPayloadError(Exception):
    """Payload parsing error."""
    ...


class PayloadAccessError(Exception):
    """Payload was accessed after response was sent."""
    ...


class RequestHandler(BaseProtocol):
    """HTTP protocol implementation.

    RequestHandler handles incoming HTTP request. It reads request line,
    request headers and request payload and calls handle_request() method.
    By default it always returns with 404 response.

    RequestHandler handles errors in incoming request, like bad
    status line, bad headers or incomplete payload. If any error occurs,
    connection gets closed.

    :param keepalive_timeout: number of seconds before closing
                              keep-alive connection
    :type keepalive_timeout: int or None

    :param bool tcp_keepalive: TCP keep-alive is on, default is on

    :param bool debug: enable debug mode

    :param logger: custom logger object
    :type logger: aiohttp.log.server_logger

    :param access_log_class: custom class for access_logger
    :type access_log_class: aiohttp.abc.AbstractAccessLogger

    :param access_log: custom logging object
    :type access_log: aiohttp.log.server_logger

    :param str access_log_format: access log format string

    :param loop: Optional event loop

    :param int max_line_size: Optional maximum header line size

    :param int max_field_size: Optional maximum header field size

    :param int max_headers: Optional maximum header size

    """
    KEEPALIVE_RESCHEDULE_DELAY = ...
    __slots__ = ...
    def __init__(self, manager: Server, *, loop: asyncio.AbstractEventLoop, keepalive_timeout: float = ..., tcp_keepalive: bool = ..., logger: Logger = ..., access_log_class: Type[AbstractAccessLogger] = ..., access_log: Logger = ..., access_log_format: str = ..., debug: bool = ..., max_line_size: int = ..., max_headers: int = ..., max_field_size: int = ..., lingering_time: float = ...):
        self.logger = ...
        self.debug = ...
        self.access_log = ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def keepalive_timeout(self) -> float:
        ...
    
    async def shutdown(self, timeout: Optional[float] = ...) -> None:
        """Worker process is about to exit, we need cleanup everything and
        stop accepting requests. It is especially important for keep-alive
        connections."""
        ...
    
    def connection_made(self, transport: asyncio.BaseTransport) -> None:
        ...
    
    def connection_lost(self, exc: Optional[BaseException]) -> None:
        ...
    
    def set_parser(self, parser: Any) -> None:
        ...
    
    def eof_received(self) -> None:
        ...
    
    def data_received(self, data: bytes) -> None:
        ...
    
    def keep_alive(self, val: bool) -> None:
        """Set keep-alive connection mode.

        :param bool val: new state.
        """
        ...
    
    def close(self) -> None:
        """Stop accepting new pipelinig messages and close
        connection when handlers done processing messages"""
        ...
    
    def force_close(self) -> None:
        """Force close connection"""
        ...
    
    def log_access(self, request: BaseRequest, response: StreamResponse, time: float) -> None:
        ...
    
    def log_debug(self, *args: Any, **kw: Any) -> None:
        ...
    
    def log_exception(self, *args: Any, **kw: Any) -> None:
        ...
    
    def _process_keepalive(self) -> None:
        ...
    
    async def start(self) -> None:
        """Process incoming request.

        It reads request line, request headers and request payload, then
        calls handle_request() method. Subclass has to override
        handle_request(). start() handles various exceptions in request
        or response handling. Connection is being closed always unless
        keep_alive(True) specified.
        """
        ...
    
    def handle_error(self, request: BaseRequest, status: int = ..., exc: Optional[BaseException] = ..., message: Optional[str] = ...) -> StreamResponse:
        """Handle errors.

        Returns HTTP response with specific status code. Logs additional
        information. It always closes current connection."""
        ...
    
    async def handle_parse_error(self, writer: AbstractStreamWriter, status: int, exc: Optional[BaseException] = ..., message: Optional[str] = ...) -> None:
        ...
    


