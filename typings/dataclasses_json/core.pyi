"""
This type stub file was generated by pyright.
"""

import json
from typing import Union

Json = Union[dict, list, str, int, float, bool, None]
class _ExtendedEncoder(json.JSONEncoder):
    def default(self, o) -> Json:
        ...
    


def _user_overrides(cls):
    ...

def _encode_json_type(value, default=...):
    ...

def _encode_overrides(kvs, overrides, encode_json: bool = ...):
    ...

def _decode_letter_case_overrides(field_names, overrides):
    """Override letter case of field names for encode/decode"""
    ...

def _decode_dataclass(cls, kvs, infer_missing):
    ...

def _support_extended_types(field_type, field_value):
    ...

def _is_supported_generic(type_):
    ...

def _decode_generic(type_, value, infer_missing):
    ...

def _decode_dict_keys(key_type, xs, infer_missing):
    """
    Because JSON object keys must be strs, we need the extra step of decoding
    them back into the user's chosen python type
    """
    ...

def _decode_items(type_arg, xs, infer_missing):
    """
    This is a tricky situation where we need to check both the annotated
    type info (which is usually a type from `typing`) and check the
    value's type directly using `type()`.

    If the type_arg is a generic we can use the annotated type, but if the
    type_arg is a typevar we need to extract the reified type information
    hence the check of `is_dataclass(vs)`
    """
    ...

def _asdict(obj, encode_json: bool = ...):
    """
    A re-implementation of `asdict` (based on the original in the `dataclasses`
    source) to support arbitrary Collection and Mapping types.
    """
    ...

