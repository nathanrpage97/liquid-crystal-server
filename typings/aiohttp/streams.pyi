"""
This type stub file was generated by pyright.
"""

import asyncio
from typing import Awaitable, Callable, Generic, Optional, Tuple, TypeVar
from .base_protocol import BaseProtocol
from .helpers import BaseTimerContext

__all__ = ('EMPTY_PAYLOAD', 'EofStream', 'StreamReader', 'DataQueue', 'FlowControlDataQueue')
DEFAULT_LIMIT = 2 ** 16
_T = TypeVar('_T')
class EofStream(Exception):
    """eof stream indication."""
    ...


class AsyncStreamIterator(Generic[_T]):
    def __init__(self, read_func: Callable[[], Awaitable[_T]]) -> None:
        self.read_func = ...
    
    def __aiter__(self) -> AsyncStreamIterator[_T]:
        ...
    
    async def __anext__(self) -> _T:
        ...
    


class ChunkTupleAsyncStreamIterator:
    def __init__(self, stream: StreamReader) -> None:
        ...
    
    def __aiter__(self) -> ChunkTupleAsyncStreamIterator:
        ...
    
    async def __anext__(self) -> Tuple[bytes, bool]:
        ...
    


class AsyncStreamReaderMixin:
    def __aiter__(self) -> AsyncStreamIterator[bytes]:
        ...
    
    def iter_chunked(self, n: int) -> AsyncStreamIterator[bytes]:
        """Returns an asynchronous iterator that yields chunks of size n.

        Python-3.5 available for Python 3.5+ only
        """
        ...
    
    def iter_any(self) -> AsyncStreamIterator[bytes]:
        """Returns an asynchronous iterator that yields all the available
        data as soon as it is received

        Python-3.5 available for Python 3.5+ only
        """
        ...
    
    def iter_chunks(self) -> ChunkTupleAsyncStreamIterator:
        """Returns an asynchronous iterator that yields chunks of data
        as they are received by the server. The yielded objects are tuples
        of (bytes, bool) as returned by the StreamReader.readchunk method.

        Python-3.5 available for Python 3.5+ only
        """
        ...
    


class StreamReader(AsyncStreamReaderMixin):
    """An enhancement of asyncio.StreamReader.

    Supports asynchronous iteration by line, chunk or as available::

        async for line in reader:
            ...
        async for chunk in reader.iter_chunked(1024):
            ...
        async for slice in reader.iter_any():
            ...

    """
    total_bytes = ...
    def __init__(self, protocol: BaseProtocol, *, limit: int = ..., timer: Optional[BaseTimerContext] = ..., loop: Optional[asyncio.AbstractEventLoop] = ...) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def exception(self) -> Optional[BaseException]:
        ...
    
    def set_exception(self, exc: BaseException) -> None:
        ...
    
    def on_eof(self, callback: Callable[[], None]) -> None:
        ...
    
    def feed_eof(self) -> None:
        ...
    
    def is_eof(self) -> bool:
        """Return True if  'feed_eof' was called."""
        ...
    
    def at_eof(self) -> bool:
        """Return True if the buffer is empty and 'feed_eof' was called."""
        ...
    
    async def wait_eof(self) -> None:
        ...
    
    def unread_data(self, data: bytes) -> None:
        """ rollback reading some data from stream, inserting it to buffer head.
        """
        ...
    
    def feed_data(self, data: bytes, size: int = ...) -> None:
        ...
    
    def begin_http_chunk_receiving(self) -> None:
        ...
    
    def end_http_chunk_receiving(self) -> None:
        ...
    
    async def _wait(self, func_name: str) -> None:
        ...
    
    async def readline(self) -> bytes:
        ...
    
    async def read(self, n: int = ...) -> bytes:
        ...
    
    async def readany(self) -> bytes:
        ...
    
    async def readchunk(self) -> Tuple[bytes, bool]:
        """Returns a tuple of (data, end_of_http_chunk). When chunked transfer
        encoding is used, end_of_http_chunk is a boolean indicating if the end
        of the data corresponds to the end of a HTTP chunk , otherwise it is
        always False.
        """
        ...
    
    async def readexactly(self, n: int) -> bytes:
        ...
    
    def read_nowait(self, n: int = ...) -> bytes:
        ...
    
    def _read_nowait_chunk(self, n: int) -> bytes:
        ...
    
    def _read_nowait(self, n: int) -> bytes:
        """ Read not more than n bytes, or whole buffer is n == -1 """
        ...
    


class EmptyStreamReader(AsyncStreamReaderMixin):
    def exception(self) -> Optional[BaseException]:
        ...
    
    def set_exception(self, exc: BaseException) -> None:
        ...
    
    def on_eof(self, callback: Callable[[], None]) -> None:
        ...
    
    def feed_eof(self) -> None:
        ...
    
    def is_eof(self) -> bool:
        ...
    
    def at_eof(self) -> bool:
        ...
    
    async def wait_eof(self) -> None:
        ...
    
    def feed_data(self, data: bytes, n: int = ...) -> None:
        ...
    
    async def readline(self) -> bytes:
        ...
    
    async def read(self, n: int = ...) -> bytes:
        ...
    
    async def readany(self) -> bytes:
        ...
    
    async def readchunk(self) -> Tuple[bytes, bool]:
        ...
    
    async def readexactly(self, n: int) -> bytes:
        ...
    
    def read_nowait(self) -> bytes:
        ...
    


EMPTY_PAYLOAD = EmptyStreamReader()
class DataQueue(Generic[_T]):
    """DataQueue is a general-purpose blocking queue with one reader."""
    def __init__(self, loop: asyncio.AbstractEventLoop) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    
    def is_eof(self) -> bool:
        ...
    
    def at_eof(self) -> bool:
        ...
    
    def exception(self) -> Optional[BaseException]:
        ...
    
    def set_exception(self, exc: BaseException) -> None:
        ...
    
    def feed_data(self, data: _T, size: int = ...) -> None:
        ...
    
    def feed_eof(self) -> None:
        ...
    
    async def read(self) -> _T:
        ...
    
    def __aiter__(self) -> AsyncStreamIterator[_T]:
        ...
    


class FlowControlDataQueue(DataQueue[_T]):
    """FlowControlDataQueue resumes and pauses an underlying stream.

    It is a destination for parsed data."""
    def __init__(self, protocol: BaseProtocol, *, limit: int = ..., loop: asyncio.AbstractEventLoop) -> None:
        ...
    
    def feed_data(self, data: _T, size: int = ...) -> None:
        ...
    
    async def read(self) -> _T:
        ...
    


