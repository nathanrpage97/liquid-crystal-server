"""
This type stub file was generated by pyright.
"""

import asyncio
from typing import Any, Optional, TYPE_CHECKING, Tuple, Union
from .typedefs import _CIMultiDict
from .client_reqrep import ClientResponse, ConnectionKey, Fingerprint, RequestInfo

"""HTTP related errors."""
if TYPE_CHECKING:
    ...
else:
    RequestInfo = ClientResponse = ConnectionKey = None
__all__ = ('ClientError', 'ClientConnectionError', 'ClientOSError', 'ClientConnectorError', 'ClientProxyConnectionError', 'ClientSSLError', 'ClientConnectorSSLError', 'ClientConnectorCertificateError', 'ServerConnectionError', 'ServerTimeoutError', 'ServerDisconnectedError', 'ServerFingerprintMismatch', 'ClientResponseError', 'ClientHttpProxyError', 'WSServerHandshakeError', 'ContentTypeError', 'ClientPayloadError', 'InvalidURL')
class ClientError(Exception):
    """Base class for client connection errors."""
    ...


class ClientResponseError(ClientError):
    """Connection error during reading response.

    request_info: instance of RequestInfo
    """
    def __init__(self, request_info: RequestInfo, history: Tuple[ClientResponse, ...], *, code: Optional[int] = ..., status: Optional[int] = ..., message: str = ..., headers: Optional[_CIMultiDict] = ...) -> None:
        self.request_info = ...
        self.message = ...
        self.headers = ...
        self.history = ...
        self.args = ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def code(self) -> int:
        ...
    
    @code.setter
    def code(self, value: int) -> None:
        self.status = ...
    


class ContentTypeError(ClientResponseError):
    """ContentType found is not valid."""
    ...


class WSServerHandshakeError(ClientResponseError):
    """websocket server handshake error."""
    ...


class ClientHttpProxyError(ClientResponseError):
    """HTTP proxy error.

    Raised in :class:`aiohttp.connector.TCPConnector` if
    proxy responds with status other than ``200 OK``
    on ``CONNECT`` request.
    """
    ...


class TooManyRedirects(ClientResponseError):
    """Client was redirected too many times."""
    ...


class ClientConnectionError(ClientError):
    """Base class for client socket errors."""
    ...


class ClientOSError(ClientConnectionError, OSError):
    """OSError error."""
    ...


class ClientConnectorError(ClientOSError):
    """Client connector error.

    Raised in :class:`aiohttp.connector.TCPConnector` if
        connection to proxy can not be established.
    """
    def __init__(self, connection_key: ConnectionKey, os_error: OSError) -> None:
        self.args = ...
    
    @property
    def os_error(self) -> OSError:
        ...
    
    @property
    def host(self) -> str:
        ...
    
    @property
    def port(self) -> Optional[int]:
        ...
    
    @property
    def ssl(self) -> Union[SSLContext, None, bool, Fingerprint]:
        ...
    
    def __str__(self) -> str:
        ...
    
    __reduce__ = ...


class ClientProxyConnectionError(ClientConnectorError):
    """Proxy connection error.

    Raised in :class:`aiohttp.connector.TCPConnector` if
        connection to proxy can not be established.
    """
    ...


class ServerConnectionError(ClientConnectionError):
    """Server connection errors."""
    ...


class ServerDisconnectedError(ServerConnectionError):
    """Server disconnected."""
    def __init__(self, message: Optional[str] = ...) -> None:
        self.message = ...
    


class ServerTimeoutError(ServerConnectionError, asyncio.TimeoutError):
    """Server timeout error."""
    ...


class ServerFingerprintMismatch(ServerConnectionError):
    """SSL certificate does not match expected fingerprint."""
    def __init__(self, expected: bytes, got: bytes, host: str, port: int) -> None:
        self.expected = ...
        self.got = ...
        self.host = ...
        self.port = ...
        self.args = ...
    
    def __repr__(self) -> str:
        ...
    


class ClientPayloadError(ClientError):
    """Response payload error."""
    ...


class InvalidURL(ClientError, ValueError):
    """Invalid URL.

    URL used for fetching is malformed, e.g. it doesn't contains host
    part."""
    def __init__(self, url: Any) -> None:
        ...
    
    @property
    def url(self) -> Any:
        ...
    
    def __repr__(self) -> str:
        ...
    


class ClientSSLError(ClientConnectorError):
    """Base error for ssl.*Errors."""
    ...


if ssl is not None:
    cert_errors = (ssl.CertificateError, )
    cert_errors_bases = (ClientSSLError, ssl.CertificateError)
    ssl_errors = (ssl.SSLError, )
    ssl_error_bases = (ClientSSLError, ssl.SSLError)
else:
    cert_errors = tuple()
    cert_errors_bases = (ClientSSLError, ValueError)
    ssl_errors = tuple()
    ssl_error_bases = (ClientSSLError, )
class ClientConnectorSSLError(ssl_error_bases):
    """Response ssl error."""
    ...


class ClientConnectorCertificateError(cert_errors_bases):
    """Response certificate error."""
    def __init__(self, connection_key: ConnectionKey, certificate_error: Exception) -> None:
        self.args = ...
    
    @property
    def certificate_error(self) -> Exception:
        ...
    
    @property
    def host(self) -> str:
        ...
    
    @property
    def port(self) -> Optional[int]:
        ...
    
    @property
    def ssl(self) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    


