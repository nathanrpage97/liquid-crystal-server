"""
This type stub file was generated by pyright.
"""

import asyncio
import logging
from typing import Any, AsyncIterator, Awaitable, Callable, Iterable, Iterator, List, Mapping, MutableMapping, Optional, Sequence, TYPE_CHECKING, Tuple, Type, Union
from .abc import AbstractAccessLogger, AbstractStreamWriter
from .frozenlist import FrozenList
from .helpers import DEBUG
from .http_parser import RawRequestMessage
from .signals import Signal
from .streams import StreamReader
from .web_protocol import RequestHandler
from .web_request import Request
from .web_response import StreamResponse
from .web_routedef import AbstractRouteDef
from .web_server import Server
from .web_urldispatcher import AbstractResource, UrlDispatcher

__all__ = ('Application', 'CleanupError')
if TYPE_CHECKING:
    _AppSignal = Signal[Callable[['Application'], Awaitable[None]]]
    _RespPrepareSignal = Signal[Callable[[Request, StreamResponse], Awaitable[None]]]
    _Handler = Callable[[Request], Awaitable[StreamResponse]]
    _Middleware = Union[Callable[[Request, _Handler], Awaitable[StreamResponse]], Callable[['Application', _Handler], Awaitable[_Handler]]]
    _Middlewares = FrozenList[_Middleware]
    _MiddlewaresHandlers = Optional[Sequence[Tuple[_Middleware, bool]]]
    _Subapps = List['Application']
else:
    _AppSignal = Signal
    _RespPrepareSignal = Signal
    _Handler = Callable
    _Middleware = Callable
    _Middlewares = FrozenList
    _MiddlewaresHandlers = Optional[Sequence]
    _Subapps = List
class Application(MutableMapping[str, Any]):
    ATTRS = ...
    def __init__(self, *, logger: logging.Logger = ..., router: Optional[UrlDispatcher] = ..., middlewares: Iterable[_Middleware] = ..., handler_args: Mapping[str, Any] = ..., client_max_size: int = ..., loop: Optional[asyncio.AbstractEventLoop] = ..., debug: Any = ...) -> None:
        self.logger = ...
    
    def __init_subclass__(cls: Type[Application]) -> None:
        ...
    
    if DEBUG:
        def __setattr__(self, name: str, val: Any) -> None:
            ...
        
    def __eq__(self, other: object) -> bool:
        ...
    
    def __getitem__(self, key: str) -> Any:
        ...
    
    def _check_frozen(self) -> None:
        ...
    
    def __setitem__(self, key: str, value: Any) -> None:
        ...
    
    def __delitem__(self, key: str) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __iter__(self) -> Iterator[str]:
        ...
    
    @property
    def loop(self) -> asyncio.AbstractEventLoop:
        ...
    
    def _set_loop(self, loop: Optional[asyncio.AbstractEventLoop]) -> None:
        ...
    
    @property
    def pre_frozen(self) -> bool:
        ...
    
    def pre_freeze(self) -> None:
        ...
    
    @property
    def frozen(self) -> bool:
        ...
    
    def freeze(self) -> None:
        ...
    
    @property
    def debug(self) -> bool:
        ...
    
    def _reg_subapp_signals(self, subapp: Application) -> None:
        ...
    
    def add_subapp(self, prefix: str, subapp: Application) -> AbstractResource:
        ...
    
    def _add_subapp(self, resource_factory: Callable[[], AbstractResource], subapp: Application) -> AbstractResource:
        ...
    
    def add_domain(self, domain: str, subapp: Application) -> AbstractResource:
        ...
    
    def add_routes(self, routes: Iterable[AbstractRouteDef]) -> None:
        ...
    
    @property
    def on_response_prepare(self) -> _RespPrepareSignal:
        ...
    
    @property
    def on_startup(self) -> _AppSignal:
        ...
    
    @property
    def on_shutdown(self) -> _AppSignal:
        ...
    
    @property
    def on_cleanup(self) -> _AppSignal:
        ...
    
    @property
    def cleanup_ctx(self) -> CleanupContext:
        ...
    
    @property
    def router(self) -> UrlDispatcher:
        ...
    
    @property
    def middlewares(self) -> _Middlewares:
        ...
    
    def _make_handler(self, *, loop: Optional[asyncio.AbstractEventLoop] = ..., access_log_class: Type[AbstractAccessLogger] = ..., **kwargs: Any) -> Server:
        ...
    
    def make_handler(self, *, loop: Optional[asyncio.AbstractEventLoop] = ..., access_log_class: Type[AbstractAccessLogger] = ..., **kwargs: Any) -> Server:
        ...
    
    async def startup(self) -> None:
        """Causes on_startup signal

        Should be called in the event loop along with the request handler.
        """
        ...
    
    async def shutdown(self) -> None:
        """Causes on_shutdown signal

        Should be called before cleanup()
        """
        ...
    
    async def cleanup(self) -> None:
        """Causes on_cleanup signal

        Should be called after shutdown()
        """
        ...
    
    def _make_request(self, message: RawRequestMessage, payload: StreamReader, protocol: RequestHandler, writer: AbstractStreamWriter, task: asyncio.Task[None], _cls: Type[Request] = ...) -> Request:
        ...
    
    def _prepare_middleware(self) -> Iterator[Tuple[_Middleware, bool]]:
        ...
    
    async def _handle(self, request: Request) -> StreamResponse:
        ...
    
    def __call__(self) -> Application:
        """gunicorn compatibility"""
        ...
    
    def __repr__(self) -> str:
        ...
    
    def __bool__(self) -> bool:
        ...
    


class CleanupError(RuntimeError):
    @property
    def exceptions(self) -> List[BaseException]:
        ...
    


if TYPE_CHECKING:
    _CleanupContextBase = FrozenList[Callable[[Application], AsyncIterator[None]]]
else:
    _CleanupContextBase = FrozenList
class CleanupContext(_CleanupContextBase):
    def __init__(self) -> None:
        ...
    
    async def _on_startup(self, app: Application) -> None:
        ...
    
    async def _on_cleanup(self, app: Application) -> None:
        ...
    


